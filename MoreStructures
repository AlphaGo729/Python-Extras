class Memory:
    '''some RAM, but able to dump to file for hard drive'''
    def __init__(self, size=0, initialData=None):
        '''Initialize memory with a given size and optional initial data.'''
        self.size = size
        self.data = initialData if initialData is not None else [0] * size

    def read(self, address):
        '''Read a value from the specified address in memory.'''
        if 0 <= address < self.size:
            return self.data[address]
        else:
            raise IndexError("Address out of range")
    def write(self, address, value):
        '''Write a value to the specified address in memory.'''
        if 0 <= address < self.size:
            self.data[address] = (value)
        else:
            raise IndexError("Address out of range")
    def filedump(self, filename):
        '''Dump the memory contents to a file.'''
        with open(filename, 'w') as f:
            f.write(self.size)
            for i in range(self.size):
                f.write(f"{i}: {self.data[i]}\n")

    def fileload(self, filename):
        '''Load memory contents from a file.'''
        with open(filename, 'r') as f:
            self.size = int(f.readline().strip())
            for line in f:
                index, value = line.split(': ')
                self.data[int(index)] = int(value.strip())
    


class GenObj:
    '''A generic object that can be used to store any data.'''
    def __init__(self, input):
        '''Initialize the object with input data.'''
        self.data = str(input)
    def __str__(self):
        '''Return a string representation of the object.'''
        return self.data
    def change(self, count):
        '''Change the data stored in the object.'''
        try:
            self.data = str(int(self.data) + count)
        except ValueError:
            return "Invalid data type for change operation"
    def get(self):
        '''Get the data stored in the object.'''
        return self.data
    def set(self, input):
        '''Set the data stored in the object.'''
        self.data = str(input)
    
class readonly:
    '''A read-only datatype that can't be changed.'''
    def __init__(self, val):
        self.val = val
    def getval(self):
        '''Get the value of the read-only attribute.'''
        return self.val
    
class Vector2D:
    '''A simple 2d vector.'''
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector2D(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector2D(self.x * scalar, self.y * scalar)

    def __truediv__(self, scalar):
        return Vector2D(self.x / scalar, self.y / scalar)

    def __repr__(self):
        return f"Vector2D({self.x}, {self.y})"
    def dot(self, other):
        '''Dot product of two vectors.'''
        return self.x * other.x + self.y * other.y
    def cross(self, other):
        '''Cross product of two vectors.'''
        if not isinstance(other, Vector2D):
            raise TypeError("Cross product is only defined between two Vector2D objects")
        return self.x * other.y - self.y * other.x
    
class Vector3D:
    '''A simple 3d vector.'''
    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z

    def __add__(self, other):
        return Vector3D(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)

    def __mul__(self, scalar):
        return Vector3D(self.x * scalar, self.y * scalar, self.z * scalar)

    def __truediv__(self, scalar):
        return Vector3D(self.x / scalar, self.y / scalar, self.z / scalar)

    def __repr__(self):
        return f"Vector3D({self.x}, {self.y}, {self.z})"
    def dot(self, other):
        '''Dot product of two vectors.'''
        return self.x * other.x + self.y * other.y + self.z * other.z
    def cross(self, other):
        '''Cross product of two vectors.'''
        return Vector3D(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

class Vector:
    '''A simple vector class that can be any dimension'''
    def __init__(self, coord):
        self.coord = coord
        self.numcoord = len(coord)
    def __add__(self, other):
        if self.numcoord != other.numcoord:
            raise ValueError("Vectors must have the same number of dimensions")
        return Vector([self.coord[i] + other.coord[i] for i in range(self.numcoord)])
    def __sub__(self, other):
        if self.numcoord != other.numcoord:
            raise ValueError("Vectors must have the same number of dimensions")
        return Vector([self.coord[i] - other.coord[i] for i in range(self.numcoord)])
    def __mul__(self, scalar):
        return Vector([c * scalar for c in self.coord])
    def __truediv__(self, scalar):
        return Vector([c / scalar for c in self.coord])
    def __repr__(self):
        return self.coord
    def dot(self, other):
        if self.numcoord != other.numcoord:
            raise ValueError("Vectors must have the same number of dimensions")
        return sum(self.coord[i] * other.coord[i] for i in range(self.numcoord))
    

class Matrix:
    '''A simple matrix class that can be any dimension'''
    def __init__(self, rows):
        self.rows = rows
        self.numrows = len(rows)
        self.numcols = len(rows[0]) if rows else 0

    def __add__(self, other):
        if self.numrows != other.numrows or self.numcols != other.numcols:
            raise ValueError("Matrices must have the same dimensions")
        return Matrix([[self.rows[i][j] + other.rows[i][j] for j in range(self.numcols)] for i in range(self.numrows)])

    def __sub__(self, other):
        if self.numrows != other.numrows or self.numcols != other.numcols:
            raise ValueError("Matrices must have the same dimensions")
        return Matrix([[self.rows[i][j] - other.rows[i][j] for j in range(self.numcols)] for i in range(self.numrows)])

    def __mul__(self, scalar):
        return Matrix([[c * scalar for c in row] for row in self.rows])

    def __repr__(self):
        return '\n'.join([' '.join(map(str, row)) for row in self.rows])
    
    def matmul(self, other):
        if self.numcols != other.numrows:
            raise ValueError("Number of columns in the first matrix must match number of rows in the second matrix")
        return Matrix([[sum(self.rows[i][k] * other.rows[k][j] for k in range(self.numcols)) for j in range(other.numcols)] for i in range(self.numrows)])
    def transpose(self):
        return Matrix([[self.rows[j][i] for j in range(self.numrows)] for i in range(self.numcols)])
    def determinant(self):
        if self.numrows != self.numcols:
            raise ValueError("Determinant is only defined for square matrices")
        if self.numrows == 1:
            return self.rows[0][0]
        if self.numrows == 2:
            return self.rows[0][0] * self.rows[1][1] - self.rows[0][1] * self.rows[1][0]
        det = 0
        for c in range(self.numcols):
            submatrix = Matrix([row[:c] + row[c+1:] for row in self.rows[1:]])
            det += ((-1) ** c) * self.rows[0][c] * submatrix.determinant()
        return det
    def inverse(self):
        if self.numrows != self.numcols:
            raise ValueError("Inverse is only defined for square matrices")
        det = self.determinant()
        if det == 0:
            raise ValueError("Matrix is singular and cannot be inverted")
        if self.numrows == 1:
            return Matrix([[1 / self.rows[0][0]]])
        cofactors = []
        for i in range(self.numrows):
            cofactor_row = []
            for j in range(self.numcols):
                submatrix = Matrix([row[:j] + row[j+1:] for row in (self.rows[:i] + self.rows[i+1:])])
                cofactor_row.append(((-1) ** (i + j)) * submatrix.determinant())
            cofactors.append(cofactor_row)
        cofactors_transposed = Matrix(cofactors).transpose()
        return cofactors_transposed * (1 / det)
    def scalevector(self, vector):
        if self.numcols != len(vector.coord):
            raise ValueError("Matrix columns must match vector dimensions")
        return Vector([sum(self.rows[i][j] * vector.coord[j] for j in range(self.numcols)) for i in range(self.numrows)])
        
